 // mt.c
// Mersenne Twister PRNG.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "mt.h"

/* ----------------------------------------------------------------------------
	Constants
*/

// constant values for MT19337
#define MT_COEFF_W 32
#define MT_COEFF_N 624
#define MT_COEFF_M 397
#define MT_COEFF_R 31

#define MT_COEFF_A 0x9908B0DF

#define MT_COEFF_U 11
#define MT_COEFF_D 0xFFFFFFFF

#define MT_COEFF_S 7
#define MT_COEFF_B 0x9D2C5680

#define MT_COEFF_T 15
#define MT_COEFF_C 0xEFC60000

#define MT_COEFF_F 1812433253

#define MT_COEFF_L 18

// default seed value for when user neglects to seed the PRNG
// this is the default value used in original implementation by Matsumoto and Nishimura
#define MT_DEFAULT_SEED 5489

/* ----------------------------------------------------------------------------
	Local Prototypes
*/

static void     mt_twist(mt_t *mt);
static uint32_t mt_temper(uint32_t y);

static void unpack(uint8_t *bytes, uint32_t word);

/* ----------------------------------------------------------------------------
	Global Variables 
*/

// not need to construct our bitmasks in every call to twist()
static const uint32_t LMASK = ((uint32_t) 1 << MT_COEFF_R) - 1;  // lower mask 
static const uint32_t UMASK = ~LMASK;                            // upper mask 

/* ----------------------------------------------------------------------------
	Exported Functions 
	See module header file (mt.h) for detailed function comments
*/

// seed the prng
int mt_seed(mt_t *mt, uint32_t seed) {
	if (!mt)
		return 1;

	// initialize the internal state 
	mt->state = calloc(MT_COEFF_N, sizeof(uint32_t));
	if (!mt->state)
		return 1;
	mt->idx      = MT_COEFF_N;
	mt->state[0] = seed; 

	for (size_t i = 1; i < MT_COEFF_N; i++) {
		// definition: xi = f * (xi−1 XOR (xi−1 >> (w−2))) + i
		mt->state[i] = MT_COEFF_F * (mt->state[i-1] ^ (mt->state[i-1] >> (MT_COEFF_W-2))) + i; 
	}

	// need to twist before returning any values,
	// might as well do it now 
	mt_twist(mt); 
	
	return 0; 
}

// initialize prng from state vector 
int mt_splice(mt_t *mt, uint32_t *state) {
	if (!mt || !state)
		return 1;

	mt->state = calloc(MT_COEFF_N, sizeof(uint32_t));
	if (!mt->state)
		return 1;
	mt->idx = 0;
	for (int i = 0; i < MT_COEFF_N; i++)
		mt->state[i] = state[i];

	// we need to twist now because the state we just recovered 
	// has since itself been twisted after exhausting 624 values 
	mt_twist(mt); 

	return 0; 
}

// extract value from rng
uint32_t mt_rand(mt_t *mt) {
	if (!mt)
		return 0;

	// if PRNG not initialized, initialize with default seed 
	if (!mt->state) 
		mt_seed(mt, MT_DEFAULT_SEED);

	// re-twist every N values 
	if (mt->idx >= MT_COEFF_N) 
		mt_twist(mt);
		
	// extract the next value from state 
	uint32_t y = mt->state[mt->idx++]; 

#ifdef DEBUG
	printf("[DEBUG] extracted state value: %08x\n", y);
#endif

	return mt_temper(y);
}

// the MT stream cipher
int mt_cipher(uint8_t *ct, uint8_t *pt, size_t mlen, uint16_t key) {
	if (!ct || !pt)
		return 1;

	mt_t mt;
	// initialize the PRNG
	mt_seed(&mt, (uint32_t) key);

	uint32_t r;            // random value generated by PRNG
	uint8_t keystream[4];  // keystream buffer

	size_t b_idx;      // block index
	size_t m_idx = 0;  // message index
	
	while (m_idx < mlen) {
		r = mt_rand(&mt);      // generate 32-bit word from PRNG
		unpack(keystream, r);  // unpack to bytes
		// encipher / decipher: out <- in XOR keystream
		for (b_idx = 0; (b_idx < 4) && (m_idx < mlen); b_idx++, m_idx++)
			ct[m_idx] = pt[m_idx] ^ keystream[b_idx];
	}

	return 0;
}

/* ----------------------------------------------------------------------------
	Local MT Functions 
*/

// twist the internal state 
static void mt_twist(mt_t *mt) {
	// update each value in the internal state 
	for (size_t i = 0; i < MT_COEFF_N; i++) {
		// straightforward masking and bitwise OR
		uint32_t bits = ((mt->state[i] & UMASK) | (mt->state[(i + 1) % MT_COEFF_N] & LMASK));

		// this code is actually worth mentioning:
		// this encompasses both the assignment to the new state value, as well as the A() function
		// the A() function typically operates as:
		// 	if (LSB of bits is 0)
		//		A(x) -> bits >> 1
		//	else (LSB of bits is 1)
		//		A(x) -> (bits >> 1) XOR A (constant)
		// but now we just do:
		//	always XOR result with bits >> 1
		//	always XOR result with (bits & 1)*A
		// we can do this because:
		// 	if LSB of bits is 0, then (bits & 1) = 0, 0*A = 0, and XOR against all 0s is nop
		//  if LSB of bits is 1, then (bits & 1) = 1, 1*A = A, and XOR against A is performed
		// 
		// finally, a practical example of predicated execution!
		mt->state[i] = mt->state[(i + MT_COEFF_M) % MT_COEFF_N] ^ (bits >> 1) ^ ((bits & 1)*MT_COEFF_A); 
	}

	// and reset the state index to 0 
	// can now produce another N random values
	mt->idx = 0; 
}

// temper PRNG output value 
static uint32_t mt_temper(uint32_t y) {
	// temper the output 
	y ^= ((y >> MT_COEFF_U) & MT_COEFF_D); 
	y ^= ((y << MT_COEFF_S) & MT_COEFF_B);
	y ^= ((y << MT_COEFF_T) & MT_COEFF_C);
	y ^= (y >> MT_COEFF_L);
	return y;
}

/* ----------------------------------------------------------------------------
	Local Helpers
*/

// unpack 32-bit word to bytes in little-endian order:
// bytes = |LSB|...|...|MSB|
static void unpack(uint8_t *bytes, uint32_t word) {
	bytes[0] = (uint8_t) (word);
	bytes[1] = (uint8_t) (word >> 8);
	bytes[2] = (uint8_t) (word >> 16);
	bytes[3] = (uint8_t) (word >> 24);
}
