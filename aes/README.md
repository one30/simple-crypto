### AES Implementation 

An implementation of the Rijndael Cipher, as described in [FIPS Publication 197](https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf), along with several cipher modes of operation, including ECB, CBC, OFB, and CTR. 

Note that this implementation attempts to maximize the 'comprehensibility' of the cipher algorithm; much is left to be desired in terms of optimization. 

### Build

This repository contains a number of subdirectories that implement various AES primitives. All of the primitives follow the following convention for builds.  

For a standard test run:

```
$ make
```

For a test run with debugging output:

```
$ make debug
``` 

To build the library for export:

```
make lib
```

To clean up after yourself:

```
$ make clean
```

### Correctness

Compare the following output with the sample cipher traces included in [the standard](https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf). 

**Cipher**

```
$ ./test
key:
2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c 
plaintext in:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
ciphertext:
39 25 84 1d 02 dc 09 fb dc 11 85 97 19 6a 0b 32 
plaintext out:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
```

**ECB Mode**

```
$ ./test
key:
2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c 
plaintext in:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
ciphertext:
39 25 84 1d 02 dc 09 fb dc 11 85 97 19 6a 0b 32 39 25 84 1d 02 dc 09 fb dc 11 85 97 19 6a 0b 32 
plaintext out:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34
```

**CBC Mode**

```
$ ./test
key:
2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c 
iv:
00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff 
plaintext in:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
ciphertext:
9b 41 3d 5a 34 ef 79 7c e0 ad 20 c6 12 5c 80 75 3c 45 67 a1 c6 cc 8f e5 02 eb 4d b2 31 eb b6 1a 
plaintext out:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
```

**CTR Mode**

```
$ ./test
key:
2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c 
plaintext in:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
ciphertext:
4f b4 9d a4 92 e2 a9 3e 0f 73 68 e5 59 2c 53 5b 86 e4 8a 8d 45 a4 d4 2d b1 5f f0 94 50 e5 91 3f 
plaintext out:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
```

**OFB Mode**

```
$ ./test 
key:
2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c 
plaintext in:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
ciphertext:
4f b4 9d a4 92 e2 a9 3e 0f 73 68 e5 59 2c 53 5b 9b 9f 03 02 9b da 66 6f 68 d6 26 f5 75 b9 75 ec 
plaintext out:
32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 32 43 f6 a8 88 5a 30 8d 31 31 98 a2 e0 37 07 34 
```

Notice how the first block (16 bytes) of ciphertext in this example is the same as that shown above in CTR mode encryption. How did this happen? Evidence of a flawed implementation? Coincidence that should occur with astronomically-low probability?

Neither: in the OFB example we use an all-zero (`\x00`) initialization vector, whereas in the CTR example we use an all-zero (`\x00`) nonce, which results in an initial all-zero (`\x00`) counter. In both cases, the first block of keystream is generated by encrypting the all-zero block with the same key, which, unsurprisingly, leads to an equivalent keystream block in both cases and thus an equivalent first block of ciphertext. In the second block where the keystream is generated differently (based on the internal update mechanisms in each mode) we observe the expected divergences.  
